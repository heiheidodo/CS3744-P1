import java.awt.Color;
import java.awt.GridLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyEvent;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Scanner;
import java.util.Vector;

import javax.swing.JFileChooser;
import javax.swing.JFrame;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTable;
import javax.swing.ListSelectionModel;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;

/**
 * Project 1: An application that displays a CSV file.
 * There are three views, table view, plot view and histogram view.
 *
 * @author Denis Gracanin
 * @version 1
 */
public class PR1 extends JFrame implements ActionListener, ChangeListener, ListSelectionListener {
	private static final long serialVersionUID = 1L;
	private final static String TITLE = "PR1: gracanin";
	private final static String HELP = "Project 1 version 1.";
	private JMenuBar menuBar = null;
	private JMenu fileMenu = null;
	private JMenu helpMenu = null;
	private JMenuItem openMenuItem = null;
	private JMenuItem closeMenuItem = null;
	private JMenuItem saveMenuItem = null;
	private JMenuItem quitMenuItem = null;
	private JMenuItem aboutMenuItem = null;

	/**
	 * Current title.
	 */
	private String title = null;

	/**
	 * Current file.
	 */
	private File file = null;

	/**
	 * The model.
	 */
	private PR1Model model = null;

	/**
	 * The table view.
	 */
	private JTable table = null;

	/**
	 * The plot view.
	 */
	private PR1Plot plot = null;

	/**
	 * The histogram view.
	 */
	private PR1Histogram histogram = null;

	private int currentPlot = -1;

	/**
	 * Creates an instance of <code>HW5</code> class using the default title.
	 */
	public PR1() {
		this(TITLE);
	}

	/**
	 * Creates an instance of <code>HW5</code> class.
	 *
	 * @param title The title of the application window.
	 */
	public PR1(String t) {
		super(t);
		title = t;
		menuBar = new JMenuBar();

		// File menu
		fileMenu = new JMenu("File");
		fileMenu.setMnemonic(KeyEvent.VK_F);

		// File->Open menu item
		openMenuItem = new JMenuItem("Open (Alt-F O)");
		openMenuItem.addActionListener(this);
		openMenuItem.setMnemonic(KeyEvent.VK_O);
		openMenuItem.setActionCommand("O");
		fileMenu.add(openMenuItem);

		// File->Close menu item
		closeMenuItem = new JMenuItem("Close (Alt-F W)");
		closeMenuItem.addActionListener(this);
		closeMenuItem.setMnemonic(KeyEvent.VK_W);
		closeMenuItem.setActionCommand("W");
		fileMenu.add(closeMenuItem);

		// File->Save menu item
		saveMenuItem = new JMenuItem("Save (Alt-F S)");
		saveMenuItem.addActionListener(this);
		saveMenuItem.setMnemonic(KeyEvent.VK_S);
		saveMenuItem.setActionCommand("S");
		fileMenu.add(saveMenuItem);

		// File->Quit menu item
		quitMenuItem = new JMenuItem("Quit (Alt-F Q)");
		quitMenuItem.addActionListener(this);
		quitMenuItem.setMnemonic(KeyEvent.VK_Q);
		quitMenuItem.setActionCommand("Q");
		fileMenu.add(quitMenuItem);

		menuBar.add(fileMenu);

		// Help menu
		helpMenu = new JMenu("Help");
		helpMenu.setMnemonic(KeyEvent.VK_H);

		// Help->About menu item
		aboutMenuItem = new JMenuItem("About (Alt-F A)");
		aboutMenuItem.addActionListener(this);
		aboutMenuItem.setMnemonic(KeyEvent.VK_A);
		aboutMenuItem.setActionCommand("A");
		helpMenu.add(aboutMenuItem);

		menuBar.add(helpMenu);

		setJMenuBar(menuBar);

		// Create the model.
		model = new PR1Model();

		// Create the table view (table).
		table = new JTable(model);

		// Configure the color scheme.
		table.setGridColor(Color.BLUE);
		table.getTableHeader().setBackground(Color.YELLOW);
		table.setSelectionBackground(Color.RED);

		// Configure the selection model.
		table.setColumnSelectionAllowed(true);
		table.setRowSelectionAllowed(true);
		table.setSelectionMode(ListSelectionModel.SINGLE_INTERVAL_SELECTION);

		// PR1 (controller) listens to the list selection events (cell selection) generated by the table view.
		//      the column has changed (the column of the selected cell).
		table.getColumnModel().getSelectionModel().addListSelectionListener(this);
		//      the row has changed (the row of the selected cell).
		table.getSelectionModel().addListSelectionListener(this);


		setLayout(new GridLayout(1,2));

		JPanel graphicsPanel = new JPanel(new GridLayout(2, 1));
		// Add the table view to the frame (within a JScrollPane object).
		graphicsPanel.add(new JScrollPane(table));

		// Create the plot view (plot).
		plot = new PR1Plot(model);


		// Data updates are directly sent to the  view.
		plot.addChangeListener(this);

		graphicsPanel.add(plot);

		add(graphicsPanel);

		histogram = new PR1Histogram(model);

		histogram.addChangeListener(this);

		add(histogram);

	}

	/**
	 * The main method.
	 * Creates the frame (application window) object, sets the size and shows it.
	 *
	 * @param args Command line arguments.
	 */
	public static void main(String[] args) {
		PR1 frame = new PR1();
		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		frame.setSize(800, 800);
		frame.setVisible(true);
	}
	/**
	 * Process the menu item selections.
	 *
	 * @param e Action event.
	 */
	@Override
	public void actionPerformed(ActionEvent e) {
		Object source = e.getSource();

		if (source instanceof JMenuItem) {
			JMenuItem menuItem = (JMenuItem) source;
			switch (menuItem.getActionCommand()) {

			case "O":
				// Open a file (select using a JFileChooser object)
				JFileChooser fileChooser = new JFileChooser();
				int returnVal = fileChooser.showOpenDialog(this);
				if (returnVal == JFileChooser.APPROVE_OPTION) {
					file = fileChooser.getSelectedFile();
					try {

						// Create input stream (a BufferdReader object) from the file.
						BufferedReader inputStream = new BufferedReader(new FileReader(file));

						// Read the first line to get the column names.
						String line = null;
						Vector<String> columnNames = new Vector<String>();
						if ((line = inputStream.readLine()) != null) {
							Scanner scanner = new Scanner(line);
							scanner.useDelimiter(",");
							while (scanner.hasNext()) {
								columnNames.add(scanner.next());
							}
							scanner.close();
						}

						// Read the remaining lines to get the data.
						Vector<Vector<String>> rowData = new Vector<Vector<String>>();
						while ((line = inputStream.readLine()) != null) {
							Vector<String> tempVector = new Vector<String>();
							Scanner scanner = new Scanner(line);
							scanner.useDelimiter(",");
							while (scanner.hasNext()) {
								tempVector.add(scanner.next());
							}
							scanner.close();
							if (columnNames.size() != tempVector.size()) {
								System.out.println("Inconsistent data!");
								return;
							}
							rowData.add(tempVector);
						}

						// Close the input stream.
						inputStream.close();

						// Store the data in the model.
						model.setDataVector(rowData, columnNames);
						setTitle(title + ": " +file.getName());
						currentPlot = -1;
					}
					catch (IOException ex) {
						System.err.println(ex);
					}
				}
				break;

			case "W":
				// CLose the model (erase the model data).
				file = null;
				model.close();
				setTitle(title);
				break;

			case "S":
				// Save the file.
				try {
					// Create output stream (a BufferdReader object) from the file.
					BufferedWriter outputStream = new BufferedWriter(new FileWriter(file));

					// Write the first line to store the column names.
					int columnCount = model.getColumnCount();
					if (columnCount > 0) {
						for (int i = 0; i < columnCount -1; i++) {
							outputStream.write(model.getColumnName(i) + ",");
						}
						outputStream.write(model.getColumnName(columnCount - 1) + "\n");
					}
					// Write data row by row.
					@SuppressWarnings("unchecked")
					Vector<Vector<String>> data = (Vector<Vector<String>>) model.getDataVector();
					for (int i = 0; i < data.size(); i++) {
						Vector<String> row = (Vector<String>) data.get(i);
						columnCount = row.size();
						if (columnCount > 0) {
							for (int j = 0; j < columnCount -1; j++) {
								outputStream.write(row.get(j) + ",");
							}
							outputStream.write(row.get(columnCount - 1) + "\n");
						}
					}
					outputStream.close();
					currentPlot = -1;
				}
				catch (IOException ex) {
					System.err.println(ex);
				}
				break;

			case "Q":
				// Exit the application.
				System.exit(0);
				break;

			case "A":
				// Show the about dialog.
				JOptionPane.showMessageDialog(this, HELP);
				break;
			}
		}
	}

	/**
	 * Processes the list selection event (cell selection from the table view) and updates the graph view selection.
	 *
	 * @param e List selection event
	 */
	@Override
	public void valueChanged(ListSelectionEvent e) {
		int c = -1; // selected column
		int r = -1; // selected row
		if (!e.getValueIsAdjusting()) {

			// If the selected column has changed, update the value of c.
			if (table.getSelectedColumns().length > 0) {
				c = table.getSelectedColumns()[0];
			}

			// If the selected row has changed, update the value of r.
			if (table.getSelectedRows().length > 0) {
				r = table.getSelectedRows()[0];
			}

			// Check if previous setValueAt attempt failed and select that cell.
			if (model.isError()) {
				c = model.getOldColumn();
				r = model.getOldRow();
				model.setError(false);
				table.setColumnSelectionInterval(c, c);
				table.getSelectionModel().setSelectionInterval(r,r);
			}

			// Use the new values of c and r to update the graph view.
			currentPlot = c;
			plot.draw(c, r);
			histogram.draw(c, r);
		}
	}

	/**
	 * Processes the change event (from the graph view) and updates the table view selection.
	 *
	 * @param e Change event
	 */
	@Override
	public void stateChanged(ChangeEvent e) {
		// Sets the selected table row based on the point selection in the graph view.
		Object source = e.getSource();
		if (source == plot) {
			table.getSelectionModel().setSelectionInterval(plot.getValue(), plot.getValue());
			histogram.draw(currentPlot, plot.getValue());
		}
		else if (source == histogram) {
			table.getSelectionModel().setSelectionInterval(histogram.getValue(), histogram.getValue());
			plot.draw(currentPlot, histogram.getValue());
		}
	}

}
